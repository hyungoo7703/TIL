# 리눅스 운영 및 관리

## 1. 파일 시스템 관련 명령어

### 파일 시스템 기본 개념

> #### 정의
운영체제가 데이터를 저장하고 찾기 위해 구성하는 체계로, 디스크의 데이터와 파일을 연결하는 구조 <br>
☞ 파일 관리 (생성, 삭제, 수정), 접근 제어 및 권한 관리 등의 주요기능을 가지고 있다.

### 주요 명령어

-----

> #### 파일시스템 관리
1. **mkfs (파일시스템 생성)**
```
mkfs -t <파일시스템종류> <장치명>

# 예시
mkfs -t ext4 /dev/sda1
```
ext3 파일 시스템을 생성할 때는 -j 옵션을 사용하는 것이 더 일반적이다. <br>
(mkfs -j ext4 /dev/sdb1 처럼은 사용할 수 없다.)

> [TIP] 파일시스템 종류
> > ext 계열: ext, ext2, ext3(저널링 기능 추가, 데이터 신뢰성 강화), ext4(현재 가장 널리 사용되는 파일시스템, 16TB 단일 파일 지원) <br>
> > 고성능 파일시스템: XFS, Btrfs, ZFS <br>
> > 특수 목적 파일시스템: iso9660, SWAP, EFI, NFS(네트워크 파일 공유 시스템)

2. **mount/umount (파일시스템 마운트/해제)**
```
mount -t [type] [device] [dir]

# 예시
sudo mount -t ext4 /dev/sda1 /mnt/data
```
  
3. **fdisk (파티션 관리)**
디스크 파티션을 확인/추가/삭제하는 명령어

> 주요 명령어:
> > **p**: 파티션 정보 출력,
> > **d**: 파티션 삭제,
> > **n**: 새 파티션 생성,
> > **w**: 변경사항 저장 후 종료,
> > **q**: 저장하지 않고 종료, <br>
> > **t**: 파티션의 속성을 변경(변경할 파티션 번호, 새로운 타입 코드를 입력)
```
# 파티션 관리 예시
sudo fdisk /dev/sdX
t
[파티션 번호]
[타입 코드]
w

# 실제 입력 예시
sudo fdisk /dev/sda
t
1
fd //83은 리눅스 파일 시스템, 8e는 Linux LVM, fd는 Linux RAID 자동 감지
w
```
-----

> #### 디스크 관리
1. **df (디스크 공간 확인)** <br>
**파일시스템**의 전체 공간과 사용량 확인

> 주요 옵션:
> > -h: 사람이 읽기 쉬운 형태로 출력,
> > -T: 파일시스템 타입 표시

2. **du (디렉토리 용량 확인)** <br>
**특정 디렉토리**의 사용량 확인

> 주요 옵션:
> > -h: 사람이 읽기 쉬운 형태로 출력,
> > -s: 총 사용량만 표시

-----

> #### 특수 권한 설정(sticky bit)
**Sticky bit**는 공용 디렉터리의 파일 보안을 위한 특수 권한 플래그 <br>
☞ 공유 디렉터리에서 "삭제 권한을 제한"하는 특별한 권한(쉽게 말해 "내 파일은 내가 지울 수 있게")

> 권한 설정 방법
> > **chmod 명령어** 이용 <br>
> > 8진수 방식(첫 자리 숫자에 1을 사용), 기호 방식(리눅스 o+t) <br>
> > 실행 권한이 있는 경우: 소문자 't'로 표시, 실행 권한이 없는 경우: 대문자 'T'로 표시
```
# 8진수 방식
chmod 1xxx 디렉터리명

# 기호 방식
chmod o+t 디렉터리명

# t와 T의 차이
# t → Sticky bit가 설정되어 있고, 실행(x) 권한도 있는 경우
drwxrwxrwt    # 777 권한 + sticky bit
# T → Sticky bit는 설정되어 있지만 실행(x) 권한이 없는 경우
drwxrwxrwT    # 776 권한 + sticky bit
```

-----

## 2. Shell 개념 및 종류

### Shell의 개념
Shell은 사용자와 커널 사이의 인터페이스 역할을 하는 명령어 해석기로, 사용자의 명령을 해석하여 커널에 전달하는 역할이다.

### 시대별 주요 쉘의 발전
1. **Bourne Shell (sh, 1979)**
+ 최초의 유닉스 기본 쉘
+ 위치: /bin/sh
+ 단순하고 가벼운 특징
2. **C Shell (csh, 1970년대 후반)** 
+ C 언어와 유사한 문법 구조
+ 히스토리 기능 도입
+ 주로 BSD 시스템(Unix 기반 운영 체제의 한 종류)에서 사용
3. **Korn Shell (ksh, 1980년대 초)**
+ Bourne 쉘 기반으로 개발
+ C 쉘의 장점을 통합
+ 상용 유닉스 시스템(AIX, Solaris)의 기본 쉘
4. **Bash (Bourne Again Shell, 1989)**
+ 현재 리눅스의 기본 쉘
+ Bourne 쉘의 확장 버전
+ 가장 널리 사용되는 쉘
5. **Z Shell (zsh, 1990년대 초)**
+ 최신 맥OS의 기본 쉘
+ Bash의 기능을 확장
+ 강력한 사용자 정의 기능

## 3. 프로세스 관리

### 프로세스의 주요 개념

> #### 프로세스
실행 중인 프로그램의 인스턴스, 그렇기에 실행 중인 프로그램은 하나 이상의 프로세스로 나타난다. <br>
(텍스트 편집기를 두 번 실행하면 두 개의 별도 프로세스가 생성) <br>
각각의 고유한 PID(Process ID) 보유하고 부모 프로세스(PPID)와 자식 프로세스 관계 형성을 한다.

> #### 프로세스 상태
+ R (Running): 실행 중
+ S (Sleeping): 대기 중
+ D (Uninterruptible Sleep): 중단 불가능한 대기
+ Z (Zombie): 종료되었으나 부모가 상태를 회수하지 않음
+ T (Stopped): 중지됨

> #### 프로세스 관리
운영 체제는 프로세스를 생성, 삭제, 스케줄링, 동기화 등을 통해 관리한다.

> 프로세스 확인
> > ps: 프로세스 상태 확인(aux: 모든 프로세스 상세 정보, -ef: 모든 프로세스를 풀 포맷으로 표시) <br>
> > top: 실시간 프로세스 모니터링(k: 특정 프로세스를 종료, r: 특정 프로세스의 우선순위를 변경) <br>
> > htop: top의 향상된 버전

> 프로세스 제어
> > kill: 프로세스에 시그널 전송(kill은 시그널 전송 명령어 임을 기억!)
```
# 일반적으로 프로세스 종료(SIGTERM(15): 정상 종료 요청 시그널)를 위한 시그널을 전송하는 데 사용되어 '종료' 명령어로 알려져 있게 되는 것이다.
kill [시그널] PID

# 강제 종료
kill -9 PID
# 정상 종료
kill -15 PID
```
> > pkill: 프로세스 이름으로 종료 <br>
> > killall: 특정 이름의 모든 프로세스 종료
> > > 주요 시그널 번호와 의미
> > > > 1. SIGHUP: 연결 종료 <br>
> > > > 2. SIGINT: 인터럽트 (Ctrl+C) <br>
> > > > 3. SIGQUIT: 종료 <br>
> > > > 9. SIGKILL: 강제 종료 <br>
> > > > 15. SIGTERM: 정상 종료 <br>
> > > > 19. SIGSTOP: 일시 중지 <br>
> > > > 20. SIGTSTP: 일시 중지 (Ctrl+Z)

> 작업 제어
> > jobs: 백그라운드 작업 목록 <br>
> > bg: 작업을 백그라운드로 보내기 <br>

[TIP] & 기호를 명령어 실행 시 맨 끝에 붙이면 '백그라운드로 실행해라' 처럼 사용 가능
```
vim c.txt &    # vim을 백그라운드로 실행
``` 
> > fg: 작업을 포그라운드로 가져오기 <br>
```
# %와 함께 사용가능(jobs 목록의 작업을 지정할 때 사용)
# 작업 번호로 지정
fg %1      # 작업 번호 1을 포그라운드로
bg %2      # 작업 번호 2를 백그라운드로
```
> > nohup: 세션 종료 후에도 프로세스 실행 유지

> 프로세스 우선순위 → 값 범위: -20(높음) ~ 19(낮음) 
> > nice: 프로세스 시작 시 우선순위 지정 <br>
> > renice: 실행 중인 프로세스의 우선순위 변경

## 4. 에디터 활용

### 주요 에디터

> #### vi (1976)
> > 빌 조이가 BSD 릴리즈용 편집기로 개발 <br>
유닉스와 리눅스의 기본 편집기로 채택 <br>
명령모드, 입력모드, 편집모드로 구성된 최초의 모드형 편집기

> #### emacs (1970년대 후반)
> > 리차드 스톨만이 매크로 기능이 있는 텍스트 편집기로 개발 <br>
제임스 고슬링이 LISP 언어 기반으로 기능 확장 <br>
LISP 기반의 환경 설정 언어 제공

> #### pico (1980년대)
> > 워싱턴 대학의 Aboil Kasar가 개발 <br>
윈도우 메모장과 유사한 인터페이스 <br>
수정 불가능한 라이센스로 인해 제한적 사용

> #### vim (1991)
> > 브람 무레나르가 vi를 개선하여 개발 <br>
vi와 호환되면서 다양한 기능 추가 <br>
구문 강조, 하이라이트 검색 등 현대적 기능 도입

> #### nano (1999)
>> 크리스 알레그레타가 개발 <br>
pico의 자유 소프트웨어 대체제로 시작 <br>
GNU 프로젝트의 일부로 편입 <br>
직관적인 사용법과 다양한 단축키 제공

> #### gedit (1990년대 후반)
> > GNOME 데스크톱 환경용으로 개발 <br>
GUI 기반의 사용자 친화적 인터페이스 <br>
크로스 플랫폼 지원

### 에디터 단축키

> #### vi/vim 단축키
```
# 커서 이동
h, j, k, l: 좌, 하, 상, 우 이동
w: 다음 단어의 시작으로 이동
b: 이전 단어의 시작으로 이동
0: 행의 처음으로 이동
$: 행의 끝으로 이동
G: 파일의 마지막 행으로 이동
gg: 파일의 첫 행으로 이동

# 편집 모드 전환
i: 현재 커서 위치에서 입력 모드
a: 현재 커서 다음 위치에서 입력 모드
o: 현재 행 다음에 새로운 행 삽입
ESC: 명령 모드로 복귀

# 저장 및 종료
:w: 저장
:q: 종료
:wq: 저장 후 종료
:q!: 강제 종료
```

> #### emacs 단축키
```
# 커서 이동
Ctrl+f: 앞으로 한 문자
Ctrl+b: 뒤로 한 문자
Ctrl+n: 다음 행
Ctrl+p: 이전 행
Ctrl+a: 행의 처음
Ctrl+e: 행의 끝

# 편집
Ctrl+d: 현재 커서의 문자 삭제
Ctrl+k: 현재 커서에서 행의 끝까지 삭제
Ctrl+y: 삭제한 텍스트 붙여넣기

# 파일 관리
Ctrl+x Ctrl+s: 저장
Ctrl+x Ctrl+c: 종료
```

> #### nano 단축키
```
# 이동
Ctrl+f: 한 문자 앞으로
Ctrl+b: 한 문자 뒤로
Ctrl+p: 이전 행
Ctrl+n: 다음 행

# 편집
Ctrl+k: 현재 행 잘라내기
Ctrl+u: 붙여넣기
Ctrl+w: 텍스트 검색

# 파일 관리
Ctrl+o: 저장
Ctrl+x: 종료
```

## 5. 소프트웨어 설치

### 설치 방식의 종류

> #### 소스 파일 컴파일 설치
[기본 설치 순서] 
1. ./configure (Makefile: 컴파일 방법을 정의한 설정 파일 생성)
2. make (소스 코드 컴파일하여 실행 파일 생성)
3. make install (컴파일된 프로그램 설치)

+ 추가 명령어
  + make clean: 컴파일된 파일 제거
  + make uninstall: 설치된 프로그램 제거
  + make distclean: 설정 파일을 포함한 모든 생성 파일 제거

> #### 바이너리 설치
이미 컴파일된 실행 파일을 압축해제하여 설치

### 패키지 관리 시스템
위 설치 방식의 의존성 문제를 해결하기 위해 패키지 매니저를 통한 설치가 등장했고, 권유되고 있다.

> #### Red Hat 계열의 패키지 관리자

1. **RPM (Red Hat Package Manager)** <br>
확장자: .rpm

> 주요 명령어:
> > rpm -i: 패키지 설치 <br>
> > rpm -e: 패키지 제거 <br>
> > rpm -qa: 설치된 모든 패키지 목록 <br>
> > rpm -qf: 특정 파일이 속한 패키지 확인 <br>
> > rpm -ql: 패키지에 포함된 파일 목록 <br>
> > rpm -Uvh: 패키지 업그레이드

2. **YUM (Yellowdog Updater Modified)**
> 주요 명령어:
> > yum install: 패키지 설치 <br>
> > yum remove(=yum erase): 패키지 제거 <br>
> > yum update: 시스템 전체 업데이트 <br>
> > yum search: 패키지 검색 <br>
> > yum list: 설치 가능한 패키지 목록 <br>
> > yum clean all: 캐시 정리

> #### Debian, Ubuntu 계열 패키지 관리자

**APT (Advanced Package Tool)** <br>
확장자: .deb

> 주요 명령어:
> > apt-get install: 패키지 설치 <br>
> > apt-get remove: 패키지 제거 <br>
> > apt-get update: 저장소 정보 갱신 <br>
> > apt-get upgrade: 설치된 패키지 업그레이드 <br>
> > apt-cache search: 패키지 검색 <br>
> > apt-cache show: 패키지 정보 표시

> #### SUSE, openSUSE 계열 패키지 관리자

**Zypper**
> 주요 명령어:
> > zypper install: 패키지 설치 <br>
> > zypper remove: 패키지 제거 <br>
> > zypper update: 시스템 업데이트 <br>
> > zypper search: 패키지 검색 <br>
> > zypper repos: 저장소 관리 <br>
> > zypper patches: 보안 패치 확인

## 6. 장치 설정

### 디스크 관리

> #### 파티션 관리
+ fdisk: 디스크 파티션 생성, 삭제, 수정
+ parted: 2TB 이상 고용량 디스크 파티션 관리

> #### 마운트 관리
+ mount: 파일시스템 마운트
+ /etc/fstab: 부팅 시 자동 마운트 설정
+ /etc/mtab: 현재 마운트된 파일시스템 정보

> #### 디스크 쿼터(사용자/그룹별 디스크 사용량 제한)
+ edquota: 사용자별 쿼터 설정
+ setquota: 명령행에서 직접 쿼터 설정

### 프린터 관리

> #### CUPS 시스템
> > IPP(Internet Printing Protocol) 기반의 오픈소스 인쇄 시스템, 네트워크 프린터 탐색과 PostScript 기반 인쇄 옵션 지원 <br>
> > 주요 설정 파일
> > > /etc/cups/cupsd.conf: CUPS 프린터 데몬의 환경 설정 파일 <br>
/etc/cups/printers.conf: 프린터 큐 관련 환경 설정 파일 <br>
/etc/cups/classes.conf: CUPS 프린터 데몬의 클래스 설정 파일 <br>

> #### 프린터 명령어

1. **BSD 계열 명령어**
> lpr: 프린터 출력 명령
> > -P: 프린터 지정
> > -#: 인쇄 매수 지정 <br>

> lpq: 프린터 큐 작업 목록 확인 <br>
> lprm: 대기 중인 작업 삭제 <br>
> lpc: 프린터 제어

2 **System V 계열 명령어**
> lp: 프린터 출력(lpr과 유사)
> > -d: 프린터 지정
> > -n: 인쇄 매수 지정 <br>

> lpstat: 프린터 상태 확인(lpq와 유사) <br>
> cancel: 프린트 작업 취소(lprm과 유사)

### 사운드 관리

> #### ALSA
> > 사운드 카드 드라이버 관리 <br>
> > 자동 설정 기능 제공 <br>
> > 다중 채널 하드웨어 믹싱 지원

> #### OSS
> > 유닉스 계열 사운드 인터페이스 <br>
> > POSIX 기반 표준 장치 지원

### 스캐너 관리

> #### SANE
> > 스캐너와 이미지 장치 제어 <br>
> > 평판/핸드 스캐너 지원 <br>
> > 비디오 캠 등 이미지 하드웨어 관리
