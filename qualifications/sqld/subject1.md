# SQL[개발자] 과목1

<hr>

## 데이터 모델링의 이해

### 1. 데이터모델의 이해

#### 데이터 모델링
+ 데이터 관점의 업무 분석 기법
+ 현실 세계의 정보를 컴퓨터 시스템에서 표현하고 저장할 수 있는 형태로 추상화하는 과정
+ 단지 시스템 구현만을 수행하는 테스크는 아님, 시스템 구현을 포함한 업무 분석 및 업무 형상화를 하는 목적
+ 복잡한 현실을 제한된 언어나 표기법으로 이해하기 쉽게하는 단순화의 의미
+ 오모함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화의 의미
+ 데이터베이스 설계의 핵심 단계로, 비즈니스 요구사항을 분석하고 이를 논리적이고 체계적인 데이터 구조로 변환하는 작업 <br>
  (데이터베이스 구축을 위한 분석 및 설계의 핵심 단계)

#### 데이터 모델링의 특징
+ **추상화**: 복잡한 현실 세계를 단순화하여 표현
+ **단순화**: 필요한 데이터만을 선별하여 모델링
+ **명확성**: 모든 사용자가 이해할 수 있도록 명확하게 표현
+ **일관성**: 데이터 구조와 규칙이 일관되게 적용
+ **유연성**: 변화하는 요구사항에 대응할 수 있도록 설계
+ **통합성**: 다양한 업무 영역의 데이터를 통합적으로 관리
+ **무결성**: 데이터의 정확성과 일관성을 보장

#### 데이터 모델링의 중요 요소
+ **Things**: 대상(Entity)
+ **Attribute**: 속성
+ **Relationships**: 관계

#### 데이터 모델링 유의점
1. 중복 → 중복이 없어야 한다.
2. 비유연성 → 유연해야 한다. (데이터의 정의와 사용 프로세스를 분리)
3. 비일관성 → 일관성이 있어야 한다.

#### 데이터 모델링의 3단계
데이터 모델링은 일반적으로 다음 3단계로 진행

1. 개념적 데이터 모델링
업무 협의적으로 이런 데이터가 필요하겠다 정도의 개념을 잡는 모델링(엔터티, ERD 작성 등)

2. 논리적 데이터 모델링
개념적 모델의 구체화 단계. 키, 속성, 관계 등을 상세하게 정의

3. 물리적 데이터 모델링
직접 물리적으로 생성하는 단계

#### 스키마(테이블, 인데스, 프로시저 등을 기술한 메타데이터 집합)
+ **외부스키마**: 사용자가 보는 관점의 스키마 구조를 표현한 것(사용자가 접근하는 대상을 view라고 한다.)
+ **개념스키마**: 통합 관점의 스키마 구조를 표현한 것
+ **내부스키마**: 데이터가 실제로 어떻게, 어디에 저장 되는지를 정의

#### 데이터 독립성
논리적 독립성 <br>
→ 데이터 베이스의 논리적 구조가 변경되어도(ex 테이블에 새로운 컬럼 추가) 응용프로그램이나 사용자 요구에 영향을 미치지 않는다. <br><br>
물리적 독립성 <br>
→ 데이터 베이스의 물리적 구조가 변경되어도(ex 저장 장치 변경 (HDD에서 SSD로), 인덱스 추가/삭제) 응용프로그램이나 사용자 요구에 영향을 미치지 않는다.

#### ERD
[정의] 1976년 피터 첸에의해 E-R모델이라는 표기법을 기초로 이를 시각적으로 그려 데이터 베이스의 설계를 위한 도구로 사용하는 것

#### ERD 작성 순서
1. 엔터티를 그린다.(엔터티를 어디에 배치하는지는 필수가 아님, 왼쪽 상단에 배치하여 이것을 중심으로 나열해가는 전개를 권장)
2. 엔터티를 적절하게 배치
3. 엔터티간 관계를 설정한다.
4. 관계명을 기술한다.(관계의 표현에서 매우 중요한 부분에 해당함)
5. 관계의 참여도를 기술한다.
6. 관계의 필수 여부를 기술한다.

> #### ERD 표기법 중 식별 관계와 비식별 관계
+ **식별 관계**: 부모 테이블의 기본키(PK)가 자식 테이블의 기본키(PK)의 일부가 되는 관계 <br>
(실선으로 표시, 자식 테이블은 부모 테이블에 강하게 종속됨) <br>
![image](https://github.com/user-attachments/assets/4d5dece4-c79a-4be7-9df4-7a2f09e7507c)
+ **비식별 관계**: 부모 테이블의 기본키가 자식 테이블의 일반 속성(외래키)으로만 전이되는 관계 <br>
(점선으로 표시, 자식 테이블이 독립적으로 존재 가능) <br>
![image](https://github.com/user-attachments/assets/82327f77-1b67-4d3b-a20b-aacf3b1b5cd2)

> #### 관계선 끝에 있는 기호로 표시 → 참조 무결성 제약조건 표기
+ **선택적(Optional) 관계**: 원형(O) 또는 점선
+ **필수적(Mandatory) 관계**: 수직선(|) 또는 실선

> #### 참조 무결성 제약조건, 역참조 무결성 제약조건
+ **참조 무결성 제약조건** <br>
외래키는 참조하는 테이블의 기본키 값과 일치하거나 NULL이어야 함 <br>
존재하지 않는 값을 참조할 수 없음 <br>
예: 주문 테이블의 고객ID는 반드시 고객 테이블에 존재하는 ID여야 함
+ **역참조 무결성 제약조건** <br>
부모 테이블의 데이터가 자식 테이블에서 참조되고 있을 경우, 부모 데이터를 삭제하거나 수정할 수 없음 <br>
자식 레코드가 있는 부모 레코드의 변경을 제한 <br>
예: 주문 내역이 있는 고객 정보는 삭제할 수 없음

### 2. 엔터티
[정의] 엔터티(Entity)는 데이터베이스에서 실제 세계의 객체나 개념을 나타내는 데이터의 기본 단위

#### 엔터티의 특징
+ 반드시 해당 업무에서 관리하고자 하는 정보
+ 유일한 식별자에 의해 식별이 가능해야 한다.
+ **2개 이상의 속성**과 **2개 이상의 인스턴스**를 가져야 한다.
+ 엔터티는 다른 엔터티와 최소 한개 이상의 관계가 있어야 한다.(최소 한개 이상의 관계는 즉시 형성하지 않아도 된다.)

#### 발생시점에 따른 엔터티의 분류
+ **기본, 키 엔터티**: 그 업무에 원래 존재하는 정보로서, 다른 엔터티에 관계에 의해 생성하지 않고 독립적으로 생성가능
+ **중심 엔터티**: 기본 엔터티로 부터 발생하고, 업무에 있어서 중심적인 역할을 수행
+ **행위 엔터티**: 두개 이상의 부모 엔터티로 부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가하는 특징이 있다.

### 3. 속성
[정의] <br>
사전적 의미로는 사물의 성질, 특징 또는 본질적인 성질이다. 이 사전적 의미 위로, 데이터 베이스 적으로는 <br>
업무에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상 더 분리되지 않는 최소 데이터 단위이다.

#### 속성의 특성에 따른 분류
+ **기본속성**: 업무로 부터 직접 추출한 속성
+ **설계속성**: 업무상 필요한 데이터 외에 데이터 모델링 과정에서 새로 만들거나 변형하여 정의
+ **파생속성**: 다른 속성의 값에 영향을 받아 발생하거나 계산되는 속성

#### 도메인
[정의] 속성이 가질수 있는 값의 범위

### 4. 관계
엔터티 간의 논리적 연관성을 표현하는 방식에 따라 두 가지로 구분
+ **존재에 의한 관계**: 엔터티의 존재 자체가 연관성을 갖는 관계(ex 사원은 부서에 소속되어 있다)
  + **연관관계**: 항상 이용하는 관계(클래스 간의 지속적인 관계)로 존재적 관계에 해당한다. <br>
    주로 멤버변수로 선언해서 사용한다. <br><br>
    ```java
    // 이해를 돕기 위해 프로그래밍 코드로 표현
    public class Bank {
      private List<Customer> customers; // 연관관계
    }
    ```
    <br>
+ **행위에 의한 관계**: 특정 행위나 업무로 인해 발생하는 관계(ex 고객이 주문하면 주문이 발생한다)
  + 의존관계: 일시적인 참조 관계로서 행위적 관계에 해당한다. <br>
    메서드의 파라미터나 지역변수로 사용한다. <br><br>
    ```java
    // 이해를 돕기 위해 프로그래밍 코드로 표현
    public class UserService {
        public void saveUser(UserRepository userRepository) { // 의존관계
            userRepository.save();
        }
    }
    ```
    <br>
ERD에서는 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다.

#### 관계의 표기법
+ **관계명**: 관계의 이름
+ **관계차수**: 1:1, 1:M, M:N
+ **선택성(선택사항)**: 필수관계, 선택관계

#### 두 개의 엔터티 사이에서 관계를 도출시 확인해야 하는 사항
1. 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
2. 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
3. 업무기술서, 장표에 관계 연결에 대한 규칙이 서술되어 있는가?
4. 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?

### 5. 식별자

#### 식별자의 종류
대표성에 따른 분류
+ **주식별자**: 엔터티를 대표하는 식별자
  > #### 주식별자의 특징
  + 유일성: 주 식별자에 의해 엔터티 내의 모든 인스턴스들은 유일하게 구분된다.
  + 존재성: 주 식별자는 반드시 데이터 값이 존재한다.
  + 불변성: 주 식별자가 한번 특정 엔터티에 지정되면 그 식별자 값은 변하지 않아야 한다.
  + 최소성: 주 식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
  
+ **보조식별자**: 대체 가능한 식별자

생성 위치에 따른 분류
+ **내부식별자**: 엔터티 내에서 스스로 생성된 식별자
+ **외부식별자**: 다른 엔터티와의 관계로 받아온 식별자

속성의 수에 따른 분류
+ **단일식별자**: 하나의 속성으로 구성
+ **복합식별자**: 두 개 이상의 속성으로 구성

의미에 따른 분류
+ **본질식별자**: 업무적으로 의미있고 실제 데이터에서 자연스럽게 식별자 역할을 하는 속성
+ **인조식별자**: 업무와 직접적인 관련은 없으나 데이터의 유일한 식별을 위해 인위적으로 만들어진 속성

<hr>

## 데이터 모델과 SQL

### 1. 정규화

#### 정규화의 주요 단계

##### 제1정규화 (1NF)
원칙: 모든 속성은 원자값(하나의 값)만 가져야 함 <br>

[예시 - 학생 취미 테이블]
```SQL
-- 정규화 전
CREATE TABLE student (
    student_id INT,
    name VARCHAR(50),
    hobby VARCHAR(100) -- 축구,게임,독서
);

-- 1정규화 후
CREATE TABLE student (
    student_id INT,
    name VARCHAR(50),
);

CREATE TABLE student_hobby (
    student_id INT,
    hobby VARCHAR(30)  -- 각각의 취미가 별도 레코드로 저장
);
```

##### 제2정규화 (2NF)
원칙: 부분적 함수 종속 제거, 모든 속성은 기본키 전체에 종속되어야 함 <br>
(기본키에 종속적이지 않거나 기본키 일부 칼럼들에만 종속적인 칼럼은 분리되어야 한다.)

[예시 - 수강신청 테이]
```SQL
-- 정규화 전
CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    student_name VARCHAR(50),
    course_fee INT,
    PRIMARY KEY (student_id, course_id)
);

-- 2정규화 후
CREATE TABLE student (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(50)
);

CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    course_fee INT,
    PRIMARY KEY (student_id, course_id)
);
```

##### 제3정규화 (3NF)
원칙: 이행적 함수 종속 제거, 기본키가 아닌 모든 속성간 종속관계 제거 <br>

[예시 - 학생 정보 테이블]
```SQL
-- 정규화 전
CREATE TABLE student (
    student_id INT PRIMARY KEY,
    dept_id INT,
    dept_name VARCHAR(50),
    dept_office VARCHAR(50)
);

-- 3정규화 후
CREATE TABLE student (
    student_id INT PRIMARY KEY,
    dept_id INT
);

CREATE TABLE department (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50),
    dept_office VARCHAR(50)
);
```

### 2. 모델이 표현하는 트랜잭션의 이해

#### 트렌젝션
[정의] 트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 작업 단위

#### 트렌젝션의 특징

**원자성(Atomicity)**
+ 트랜잭션의 연산은 모두 반영되거나 전혀 반영되지 않아야 함
+ 예: 계좌이체 시 출금과 입금이 모두 성공하거나 모두 실패해야 함

**일관성(Consistency)**
+ 트랜잭션 실행 전과 후의 데이터베이스 상태가 일관되어야 함
+ 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관된 상태를 유지

**독립성(Isolation)**
+ 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 함
+ 한 트랜잭션의 중간 결과가 다른 트랜잭션에게 숨겨져야 함

**지속성(Durability)**
+ 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함
+ 시스템 장애가 발생해도 데이터는 보존되어야 함

### 3. Null 속성의 이해
[정의] <br>
'알 수 없는 값' 또는 '적용할 수 없는 값'을 의미 <br>
0이나 공백('')과는 다른 개념이며 데이터가 존재하지 않음을 나타내는 특수한 값

#### Null의 특징

연산적 특징
+ NULL과의 연산 결과는 항상 NULL
+ 비교 연산자(=, <, >, <>)로 비교 불가능
+ NULL끼리의 비교도 불가능

처리 방법
+ IS NULL, IS NOT NULL 연산자 사용 필요
+ NULL 처리를 위한 특수 함수 사용 (COALESCE, NVL, ISNULL 등)
+ 정렬 시 가장 작은 값으로 취급됨
