# 해시(Hash) 구조
해시 구조는 **Key-Value 쌍**으로 데이터를 저장하는 자료구조이다.
내부적으로 배열을 사용해서 데이터를 저장하기 때문에, 특정 값에 대한 검색과 삽입이 매우 빠르게 이루어진다.
핵심은 **해시 함수(Hash Function)**를 사용하는 건데, 이 함수가 Key를 받아서 배열의 특정 인덱스(Index)로 변환해준다.
그래서 평균적으로 **O(1)**이라는 아주 빠른 시간 복잡도로 데이터에 접근할 수 있다.

## 해시의 핵심 구성 요소
- **Key**: 데이터의 고유한 식별자. 찾고 싶은 데이터를 구분하는 데 사용된다.
- **Value**: Key에 해당하는 실제 데이터
- **해시 함수 (Hash Function)**: Key를 받아서 정수 값인 **해시 코드(Hash Code)**로 변환하는 함수. 이 해시 코드를 배열의 크기로 나눠서 최종 인덱스를 결정
- **해시 테이블 (Hash Table)**: Key-Value 쌍을 저장하는 배열 구조. **버킷(Bucket)** 또는 **슬롯(Slot)**이라고도 부른다.

## 해시 충돌 (Hash Collision)
해시 구조의 가장 중요한 과제는 바로 **해시 충돌**을 어떻게 처리하느냐가 중요하다.

> **해시 충돌이란?**
> 서로 다른 Key를 해시 함수에 넣었는데, 같은 인덱스가 나오는 현상이다.

아무리 해시 함수를 잘 만들어도, Key의 개수는 무한한데 인덱스의 수는 한정되어 있으니 충돌은 피할 수 없다.
그래서 이 충돌을 어떻게 효율적으로 해결하는지가 해시 구조의 성능을 좌우한다.

### 충돌 해결 방법

#### 1. 체이닝 (Chaining)
가장 널리 쓰이는 방법. Java의 `HashMap`도 이 방식을 기본으로 사용해

- **동작 방식**: 충돌이 발생하면, 같은 인덱스에 있는 데이터들을 **연결 리스트(Linked List)**로 연결해서 저장하는 한다.
- **장점**: 구현이 비교적 간단하고, 데이터가 많아져도 유연하게 대처할 수 있다.
- **단점**: 한 인덱스에 데이터가 너무 많이 몰리면, 연결 리스트의 탐색 시간이 길어져서 성능이 저하될 수 있다. (최악의 경우 O(n))

> **Java 8의 HashMap 개선**
> Java 8부터는 체이닝 방식의 단점을 보완하기 위해, 하나의 버킷에 있는 데이터 개수가 특정 임계값(기본 8개)을 넘어가면, 연결 리스트를 **레드-블랙 트리(Red-Black Tree)** 구조로 바꿔서 저장한다. 이렇게 하면 최악의 경우에도 탐색 성능이 O(log n)으로 보장되기 때문이다.

#### 2. 개방 주소법 (Open Addressing)
충돌이 발생했을 때, 다른 비어있는 버킷을 찾아서 데이터를 저장하는 방식. 모든 데이터가 해시 테이블 배열 안에 직접 저장된다.

- **선형 탐사 (Linear Probing)**: 충돌이 나면, 바로 다음 인덱스에 비어있는 공간이 있는지 순차적으로 확인
- **제곱 탐사 (Quadratic Probing)**: 충돌 시, `1^2`, `2^2`, `3^2`... 만큼 떨어진 인덱스를 확인
- **이중 해싱 (Double Hashing)**: 2개의 해시 함수를 사용해서, 충돌 시 두 번째 해시 함수의 결과만큼 인덱스를 건너뛰어 확인

- **장점**: 추가적인 자료구조(연결 리스트 등)를 사용하지 않아 메모리 효율이 좋다.
- **단점**: 데이터가 특정 영역에 몰리는 **클러스터링(Clustering)** 현상이 발생하기 쉽고, 데이터 삭제가 까다롭다.

## 언제 사용할까?
- 데이터 검색이 매우 빈번할 때
- Key를 통해 중복 없는 데이터를 관리하고 싶을 때 (Set)
- Key와 Value를 매핑해서 데이터를 관리하고 싶을 때 (Map)

Java의 `HashMap`, `HashSet`이 바로 이 해시 구조를 기반으로 만들어진 대표적인 컬렉션임을 기억한다.
