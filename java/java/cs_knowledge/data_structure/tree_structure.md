# 트리(Tree) 구조

트리는 이름 그대로 나무를 거꾸로 뒤집어 놓은 듯한 형태의 **계층적 자료구조**이다.

하나의 루트(Root) 노드에서 시작해서, 여러 개의 자식 노드가 가지처럼 뻗어 나가는 구조로, 그래프의 한 종류이다. 가장 큰 특징은 **사이클(Cycle)이 없는 연결 그래프**라는 점이다.

## 📌 트리 관련 주요 용어

![트리 용어](https://i.imgur.com/VpYt42s.png)

- **노드 (Node)**: 트리를 구성하는 기본 요소. 데이터와 다른 노드를 가리키는 참조
- **루트 (Root)**: 트리 계층의 가장 최상위에 있는 노드 (A)
- **간선 (Edge)**: 노드와 노드를 연결하는 선
- **부모 노드 (Parent Node)**: 어떤 노드의 상위 노드 (A는 B의 부모)
- **자식 노드 (Child Node)**: 어떤 노드의 하위 노드 (B는 A의 자식)
- **형제 노드 (Sibling Node)**: 같은 부모를 갖는 노드들 (D, E, F는 서로 형제)
- **리프 노드 (Leaf Node)**: 자식이 없는 맨 끝의 노드 (K, L, M, N, I, J)
- **깊이 (Depth)**: 루트에서 특정 노드까지의 경로 길이(간선의 수). 루트의 깊이는 0
- **높이 (Height)**: 특정 노드에서 리프 노드까지의 가장 긴 경로 길이. 리프의 높이는 0

## 📌 트리의 종류

트리는 노드의 구성이나 특징에 따라 여러 종류로 나뉜다.

### 이진 트리 (Binary Tree)

모든 노드의 자식 노드 수가 2개 이하인 트리를 말한다. 가장 많이 쓰이는 트리 구조 중 하나

- **포화 이진 트리 (Full Binary Tree)**: 모든 노드가 0개 또는 2개의 자식 노드를 가짐
- **완전 이진 트리 (Complete Binary Tree)**: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 채워짐

### 이진 탐색 트리 (Binary Search Tree, BST)

이진 트리에 데이터 검색에 용이한 특징을 더한 구조

- **특징**
  - 모든 노드의 왼쪽 서브트리에는 부모 노드보다 작은 값만 존재
  - 모든 노드의 오른쪽 서브트리에는 부모 노드보다 큰 값만 존재
  - 모든 서브트리 또한 이진 탐색 트리의 속성을 만족
- **장점**: 데이터의 정렬 상태를 유지하므로, 평균적으로 O(log n)의 빠른 시간 복잡도로 검색, 삽입, 삭제가 가능
- **단점**: 데이터가 한쪽으로 치우쳐 저장될 경우(편향 트리), 성능이 O(n)까지 저하될 수 있다. 이를 보완하기 위해 `AVL 트리`, `레드-블랙 트리` 같은 **자가 균형(Self-Balancing) 이진 탐색 트리**를 사용하기도 한다.

## 📌 트리 순회 (Tree Traversal)

트리의 모든 노드를 한 번씩 방문하는 방법, 대표적으로 3가지 이다.

- **전위 순회 (Pre-order)**: `루트 -> 왼쪽 -> 오른쪽` 순서로 방문 (A -> B -> D -> E -> C -> F -> G)
- **중위 순회 (In-order)**: `왼쪽 -> 루트 -> 오른쪽` 순서로 방문. 이진 탐색 트리에서 중위 순회를 하면 데이터가 정렬된 순서로 나옴 (D -> B -> E -> A -> F -> C -> G)
- **후위 순회 (Post-order)**: `왼쪽 -> 오른쪽 -> 루트` 순서로 방문 (D -> E -> B -> F -> G -> C -> A)

### Java로 간단히 구현해보기

```java
// 기본적인 트리 노드
class Node {
    int data;
    Node left;  // 왼쪽 자식
    Node right; // 오른쪽 자식

    Node(int data) {
        this.data = data;
    }
}

public class TreeTraversal {

    // 중위 순회 (In-order)
    public void inorder(Node node) {
        if (node != null) {
            inorder(node.left);
            System.out.print(node.data + " "); // 1. 왼쪽 탐색 후 자기 자신 출력
            inorder(node.right);
        }
    }
}
```
